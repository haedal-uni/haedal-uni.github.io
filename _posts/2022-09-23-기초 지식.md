---
categories: Study
tags: [spring, study, summary, ch2]
---

## 서버 간 통신

<br><br>

---

## 스프링 부트의 동작 방식

**용어**                    

***Servlet*** [서블릿] : 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술            

***Servlet Container*** [서블릿 컨테이너] : 서블릿 인스턴스를 생성, 관리.                        
  스프링 부트의 경우 톰캣이 WAS의 역할과 스블릿 컨테이너의 역할을 수행한다.

***Dispatcher Servlet*** [디스패처 서블릿] : 스프링 내부의 서블릿       

**HandlerMapping** : 특정 요청 경로를 처리해주는 핸들러를 찾아주는 객체

<br>


1. Servlet Container가 스프링 Dispatcher Servlet에 클라이언트 요청을 전달.                                                      
  (Servlet Container 와 Dispatcher Servlet 사이에 여러 filter 들이 존재.)                                          
2. 핸들러 매핑이 요청 URI에 매핑된 핸들러(≒Controller)를 탐색.                                          
3. 핸들러 리턴.                                          
4. 핸들러에 맞는 핸들러 어댑터 탐색.                                          
5. 핸들러 호출.                                          
6. 값 리턴.                                          
7. 리턴 받은 값을 ModelAndView로 가공해 반환.                                          
8. 뷰 형식인 경우 뷰 이름 전달.                                          
9. 뷰 리턴.                                          
10. 모델 전달.
11. 모델을 담아 뷰 리턴.                                          
12. 응답

위의 과정을 거쳐 클라이언트의 요청에 따라 응답한다.         

뷰가 없는 REST 형식을 적용할 경우 스프링 내부의 MessageConverter가 요청과 응답 Body를 알아서 변환한다.                                    

이러한 복잡한 과정을 스프링에서 해주고있기 때문에 개발자는 비즈니스 로직에 집중할 수 있다.    

<br>

![image](https://user-images.githubusercontent.com/74857364/191558783-4e628291-30d9-4422-8118-872ff6bd60e0.png)

DispatcherServlet은 모든 연결을 담당한다.           

1️⃣ 웹 브러우저로부터 요청이 들어오면 

   DispatcherServlet은 그 요청을 처리하기 위한 Controller 객체를 검색하는데,    
                 
2️⃣ 이 때 DispatcherServlet이 직접 검색하지 않고 HandlerMapping이라는 빈 객체에게 Controller 검색을 요청한다.

   HandlerMapping은 클라이언트의 요청 경로를 이용해서 이를 처리할 Controller 빈 객체를 DispatcherServlet에 전달한다.

<br>

3️⃣ DispatcherServlet은 HandlerMapping이 찾아 준 컨트롤러 객체를 처리할 수 있는 HandlerAdapter 빈에게 요청 처리를 위임한다.

   HandlerAdapter는 @Controller, Controller 인터페이스, HttpRequestHandler 인터페이스를 동일한 방식으로 처리하기 위해 사용된다.

<br>

4️⃣,5️⃣ HandlerAdapter는 컨트롤러의 알맞은 메서드를 호출해서 요청을 처리하고

6️⃣ 그 결과를 DispatcherServlet에 리턴한다.

   이때, HandlerAdapter는 컨트롤러의 처리 결과를 ModelAndView라는 객체로 변환해서 DispatcherServlet에 리턴한다.

<br>

7️⃣ DispatcherServlet은 결과를 보여줄 뷰를 찾기 위해 ViewResolver 빈 객체를 사용한다.                                      

8️⃣ DispatcherServlet은 ViewResolver가 리턴한 View 객체에게 응답 결과 생성을 요청한다.                   

9️⃣ JSP를 사용하는 경우 View 객체는 JSP를 실행함으로써 끝이 난다.                  

<br>

DispatcherServlet은 핸들러 객체의 실제 타입에 상관 없이 실행 결과를 ModelAndView라는 타입으로만 받을 수 있으면 되는데,                     
ModeAndView를 리턴하지 않는 객체도 있다.                               
                  
이 때, Handler의 처리 결과를 ModelAndView로 변환해주는 객체가 필요하며, HandlerAdapter가 바로 이 변환을 수행해준다.            

                             
*Spring MVC에서는 ModelAndView로 변환해서 리턴하고 RestController에서는 Json으로 Serialize되어 반환된다.                         

<br><br>

---

## 레이어드 아키텍처
**스프링 MVC 모델 레이어드 아키텍처**
- 컴포넌트를 비슷한 관심사에 따라 레이어로 묶어 구성한 구조.

- 일반적으로 3계층 또는 4계층으로 구성.

<br>

### 레이어드 아키텍처 특징
- 가장 가까운 하위 레이어의 의존성을 주입.

- 다른 레이어의 역할을 침범하지 않음.

- 다른 레이어의 의존성을 낮춰 단위 테스트에 용이.

<br>

### 계층

#### 프레젠테이션 계층
- 유저 인터페이스 계층이라고도 함.

- 클라이언트이 요청을 해석하고 응답.

- UI나 API를 제공.

- 비즈니스 로직을 포함하고 있지 않음.

- 비즈니스 계층으로 요청을 위임, 전달해주고 받은 결과를 응답.

<br>

#### 비즈니스 계층

- 서비스 계층이라고도 함.

- 기능을 정의하고 세부 작업을 수행.

- 도메인 객체를 통해 업무를 위임.

- DDD (Domain-Driven Design) 개발 시 비즈니스 로직에 도메인이 포함되기도 하고, 별도로 도메인 계층을 두기도 함.

- 트랜잭션 처리나 유효성 검사 등의 작업도 수행.

<br>

#### 데이터 접근 계층

- 영속(Persistence) 계층이라고도 함.

- 데이터베이스에 접근하는 작업 수행.

<br><br>

---

## 디자인 패턴
소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.

디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램의 최적화에 도움이 된다.

<br><br>

**디자인 패턴 구성요소**

| 구성요소 | 설명 |
| --- | --- |
| 패턴의 이름 | 디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형 |
| 문제 및 배경 | 디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미 |
| 솔루션 | 디자인 패턴을 이루는 요소들, 관계, 협동 과정 |
| 사례 | 디자인 패턴의 간단한 적용 사례 |
| 결과 | 디자인 패턴을 사용하면 얻게 되는 이점이나 영향 |
| 샘플 코드 | 디자인 패턴이 적용된 원시 코드 |

<br><br>

### 디자인 패턴의 종류

<br>

**생성 패턴**

객체 생성에 관련된 패턴이다. 

객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.
<br>

| 패턴  | 설명 |
| --- | --- |
| Builder | 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴, 생성과 표기를 분리해서 복잡한 객체를 생성 |
| Prototype | 기존 객체를 복제함으로써 객체를 생성 |
| Factory Method | 생성할 객체의 클래스를 국한하지 않고 객체를 생성 |
| Abstract Factory | 동일한 주제의 다른 팩토리를 묶음 |
| Singleton | 한 클래스에 한 객체만 존재하도록 제한 |

<br>
<br>

**구조 패턴**

클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.

예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나

객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.
<br>

| 패턴  | 설명 |
| --- | --- |
| Bridge | 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용 |
| Decorator | 객체의 결합을 통해 기능을 동적으로 유연하게 확장 |
| Facade | 통합된 인터페이스 제공 |
| Flyweight | 여러 개의 ‘가상 인스턴스’를 제공하여 메모리 절감 |
| Proxy | 특정 객체로의 접근을 제어하기 위한 용도로 사용 |
| Composite | 복합 객체와 단일 객체를 동일하게 취급 |
| Adapter | 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움 |

<br><br>

**행위 패턴**

객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴한 객체가 혼자 수행할 수 없는 작업을

여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 **객체 사이의 결합도를 최소화하는 것에 중점**을 둔다.
<br>

| 패턴 | 설명 |
| --- | --- |
| Mediator | 상호작용의 유연한 변경을 지원 |
| Interpreter | 문법 자체를 캡슐화하여 사용 |
| Iterator | 내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴 |
| Template Method | 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행 |
| Observer | 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존 |
| State | 객체의 상태 변화에 따라 행위 내용을 변경 |
| Visitor | 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위 |
| Command | 요구사항을 객체로 캡슐화 |
| Strategy | 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환 |
| Memento | 객체를 이전 상태로 복구시켜야 하는 경우 ‘작업취소(Undo)’ 요청 가능 |
| Chain of Responsibility | 한 요청을 2개 이상의 객체에서 처리 |

<br><br>

---

## REST API
### REST란?
자원(resource)의 표현(representation)에 의한 상태 전달

자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.

<br><br>

### REST API란?

**API란?**                 
데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는 것                


**REST API**                
REST 기반으로 서비스 API를 구현한 것                

<br><br>

### REST의 특징
- 서버-클라이언트 구조                
    - 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client                
- 무상태(Stateless)                

<br><br>

### REST의 URI 설계 규칙
resource에 동사보다는 명사를 사용한다.                

resource에 대문자 보다는 소문자를 사용한다.                

URI에 HTTP Method가 들어가면 안된다.

URI에 행위에 대한 동사 표현이 들어가면 안된다. (CRUD 기능을 나타내는 것은 URI에 사용하지 않는다.)                
ex. `/members/show/1` → `/members/1`


<br><br><br>

출처             
[[디자인패턴 분류] 생성/구조/행위 패턴](https://velog.io/@jinh2352/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-%EB%B6%84%EB%A5%98-%EC%83%9D%EC%84%B1%EA%B5%AC%EC%A1%B0%ED%96%89%EC%9C%84-%ED%8C%A8%ED%84%B4)                 
[정보처리기사 실기 vol.1]                                                     
[[Network] REST란? REST API란? RESTful이란?](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)                           
[10. 스프링 MVC 프레임워크 동작 방식](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=sks6624&logNo=220794528484)         

